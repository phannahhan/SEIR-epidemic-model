# -*- coding: utf-8 -*-
"""Group Project 1 Individual Agent Model_v2_age_stratified_updated.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t2kzDEjmozuvXzkMRF8T6zCxsHekJeOo
"""

import numpy as np
import matplotlib.pyplot as plt
import random
from collections import defaultdict

"""### Helpful Resources

Available data indicate that persons with mild to moderate COVID-19 remain infectious no longer than 10 days after symptom onset. Persons with more severe to critical illness or severe immunocompromise likely remain infectious no longer than 20 days after symptom onset

https://www.cdc.gov/coronavirus/2019-ncov/hcp/duration-isolation.html#:~:text=Available%20data%20indicate%20that%20persons,days%20after%20symptom%20onset

- inspired the `min_infect` and `max_infect` variables

### Global Variables Summary

- 's': susceptible population, capable of contracting infection if in contact with an exposed, infected, or undetected individual

- 'e': exposed population; these are people who have contracted the virus and are contagious, but are not yet symptomatic (incubation period)

- 'i': infected population; these are the symptomatic individuals (can either recover or die)

- 'u': undetected population; these are the people who are asymptomatic but can spread the virus (can only recover)

- 'r': recovered population; these are people who have recovered from an infection

- 'f': population who have died; this is the fatality count

Potential outcomes for individuals:

s

s -> e -> i -> r

s -> e -> i -> f

s -> e -> u -> r

### Notes

`nc1_lam` and `nc2_lam` may be affected by social distancing policies. We expect `nc2_lam` < `nc1_lam` since unwell individuals are less likely to move around and come in contact with other individuals.

`incubate_time` is just a constant, but we can vary this (uniform distribution perhaps). It was set to the shorter end of the expected incubation period of covid because this individual could turn out to be undetected, at which they would be contagious for a total of 2+5=7 to 2+10=15 days.

`min_infect` and `max_infect` are the minimum and maximum number of days an infected or undetected (`i` or `u`) individual is contagious, excluding the incubation period, at which their status is `e`

`p_e`, `p_i`, `p_u`, and `p_f` are the probabilities of becoming exposed after contact (`s` -> `e`), symptomatic (`e` -> `i`), asymptomatic (`e` -> `u`), and dying (`i` -> `f`), respectively. We assume that only symptomatic individuals may die.

### To Do

- Changing fatality rate (`p_f`) depending on age of the individual

- Different probability of being infected based on age of the individual

- `nc1_lam` and `nc2_lam` probably vary across age groups as well

- Maybe `p_e` would change too, depending on age?


Perhaps we can create an array that contains the age information of each individual agent in `pop` (indices of the `pop` array correspond directly to the indices in this new array). We can then pass this array on to the census1D array, much like what was done with the dictionaries `t_e`, `t_i`, and `t_u`.

Maybe we can also have function simulate1D return this array of age information so that we can plot the SEIURF for each age groups.
"""

# GLOBAL VARIABLES
n = 10000 # population

# nc1_lam = 1 # rate of contacts per day of exposed people (modelled by Poisson)
nc2_lam = 0.5 # rate of contacts per day of symptomatic infected people (modelled by Poisson)

incubate_time = 2 # days that incubation lasts (before an 'e' individual becomes 'i', symptomatic, or 'u', asymptomatic)

# generate uniform distribution (nearest integer)
min_infect = 5 # minimum number of days infected or undetected person (i.e. symptomatic or asymptomatic) is contagious
max_infect = 15 # maximum number of days infected or undetected person (i.e. symptomatic or asymptomatic) is contagious

# probabilities
# p_e = 0.3     # prob of being exposed after contact 

# infected/symptomatic rates by age
pi_children = 0.2
pi_young_adult = 0.4
pi_adult = 0.6
pi_elderly = 0.8

# p_i = 0.75    # prob of becoming symptomatic / infected

# p_u = 1 - p_i # prob of becoming asymptomatic (undetected)

# fatality rates by age group
pf_children = np.random.uniform(0,0.002)
pf_young_adult = np.random.uniform(0.002,0.003)
pf_adult = np.random.uniform(0.003,0.036)
pf_elderly = np.random.uniform(0.06,0.2)

# p_f = 3.3/100    # prob of a fatality (assuming only symptomatic individuals may die)

tt, results, results_by_age = simulate1D()

plt.figure()

labels = ['S', 'E', 'I', 'U', 'R', 'F']

for y_arr, label in zip(np.transpose(results), labels):
    plt.plot(tt, y_arr, label=label)
    
plt.title('Evolution of Populations over Time')
plt.xlabel('Time (days)')
plt.ylabel('Population')
plt.legend();

plot_realizations(10)

"""# Functions"""

def simulate1D():
    """
    this function packages the simulation steps of intializing the population
    vector and iterating the epidemic and census functions unit I=0
    the censuses are accumulated in a matrix, results
    """
    t=0 # counts number of days, starting from the 0th day
    pop=initial1D(n,0,0,0,0,0) # initial susceptible, exposed, infected, recovered, and undetected
    
    # dictionaries to keep track how many days are left before an individual's 'e', 'i', or 'u' state will change
    t_e = {} # days left of the exposed/incubation period
    t_i = {} # days left for the infected period
    t_u = {} # days left for the undetected period
    ages = age_of_each_ind(len(pop))
    
    pop[int(n/2)-1]='i' # 1 infection to start with
    t_i[int(n/2)-1]=int(np.random.uniform(min_infect,max_infect)) # add number of days left the individual has of being infected

    s,e,i,u,r,f=census1D(pop) # get the number of individuals in each state
    results=[[s,e,i,u,r,f]] # add starting populations into an array
    results_by_age = [group_states_by_age(ages, pop)]
    tt=[t] # keep track of the timesteps
    
    # as long as there is an exposed, infected, or undetected individual, the infection will continue to spread
    while e>0 or i>0 or u>0:
        # pass population as well as dictionaries (days each e, i, u individual have left in their current state)
        pop, t_e, t_i, t_u=epidemic1D_age(pop, ages, t_e, t_i, t_u) 
        
        states_by_age_in_timestep = group_states_by_age(ages, pop)
        results_by_age.append(states_by_age_in_timestep)
        
        s,e,i,u,r,f=census1D(pop) # get the number of individuals in each state
        results.append([s,e,i,u,r,f]) # add current population into an array
        
        
        # update time
        t=t+1
        tt.append(t)
        
    # return time and results
    return tt,results, results_by_age

def group_states_by_age(ages, pop):
    """
    this function, when passed in a list of age groups and a list of states corresponding to each individual
    in the population, returns a dictionary where the key is the age group and the value is a list containing
    counts of the number of people in that age group that correspond to each state s,e,i,u,r,f respectively
    """
    # create list of tuples where first elem is age of ind. and second elem is state of ind. at current timestep
    ages_states_zipped = list(zip(ages, pop))

    # group ages_states_zipped by age to get total in each state by age
    # returned dict has key of age, value is a list containing the number of individuals of that age 
    # in each given state at timestep        
    states_by_age_in_timestep = {}
    for (age_iter, state_iter) in ages_states_zipped:
        if states_by_age_in_timestep.get(age_iter) == None:
            states_by_age_in_timestep[age_iter] = [state_iter]
        else:
            states_by_age_in_timestep[age_iter].append(state_iter)
    
    final_dict = {}
    for age_group in list(states_by_age_in_timestep.keys()):
        try:
            stats_per_group = census1D(states_by_age_in_timestep[age_group])
            final_dict[age_group] = stats_per_group
        except:
            final_dict[age_group] = [(0,0,0,0,0,0)]
    return final_dict

def initial1D(s0,e0,i0,u0,r0,f0):
    '''
    sets an initial population vector for the epidemic simulation
    each state subpopulation is appended to the growing vector, pop
    NOTE: if position in the array is important,eg. if you are modeling
    local neighborhood contacts, each individual must be placed 
    randomly in the array
    '''
    
    pop=[] # array of individual agent states
    
    # add the states of the individual agents into the array
    for i in range(s0):
        pop.append('s')
    for i in range(e0):
        pop.append('e')
    for i in range(i0):
        pop.append('i')
    for i in range(u0):
        pop.append('u')
    for i in range(r0):
        pop.append('r')
    for i in range(f0):
        pop.append('f')
        
    # randomizes individuals in array
    return pop

def census1D(pop):
    # counts the number of s, e, i, r, u, and f cells in pop
    s=0 # susceptible
    e=0 # exposed
    i=0 # infected
    u=0 # undetected
    r=0 # recovered
    f=0 # fatalities
    n=np.array(pop).shape[0]

    for j in range(n):
        if pop[j]=='s':
            s+=1
        elif pop[j]=='e':
            e+=1
        elif pop[j]=='i':
            i+=1
        elif pop[j]=='u':
            u+=1
        elif pop[j]=='r':
            r+=1
        elif pop[j]=='f':
            f+=1
    return s,e,i,u,r,f

def age_of_each_ind(pop):
    
    pop_age_groups = [''] * pop
    
    for ind in range(pop):
        
        age_bracket = np.random.rand()
        if age_bracket <= 0.25:
            pop_age_groups[ind] = 'C'
        elif age_bracket > 0.25 and age_bracket <= 0.47:
            pop_age_groups[ind] = 'Y'
        elif age_bracket > 0.47 and age_bracket <= 0.86:
            pop_age_groups[ind] = 'A'
        else:
            pop_age_groups[ind] = 'E'
            
    return pop_age_groups

def age_based_p_f(age):
    if age == 'C':
        p_f = np.random.uniform(0,0.002)
    elif age == 'Y':
        p_f = np.random.uniform(0.002,0.003)
    elif age == 'A':
        p_f = np.random.uniform(0.003,0.036)
    else:
        p_f = np.random.uniform(0.06,0.2)
    return p_f

def age_based_p_i(age):
    if age == 'C':
        p_i = pi_children
    elif age == 'Y':
        p_i = pi_young_adult
    elif age == 'A':
        p_i = pi_adult
    else:
        p_i = pi_elderly
    return p_i

def age_based_p_e(age):
    if age == 'C':
        p_e = random.choices([0.1, 0.3], [0.3, 0.7])[0]
    elif age == 'Y':
        p_e = random.choices([0.1, 0.3], [0.4, 0.6])[0]
    elif age == 'A':
        p_e = random.choices([0.1, 0.3], [0.6, 0.4])[0]
    else:
        p_e = random.choices([0.1, 0.3], [0.7, 0.3])[0]


#     if age == 'C':
#         p_e = random.choices([0.08, 0.1, 0.2, 0.3], [0.5, 0.01, 0.44, 0.05])[0]
#     elif age == 'Y':
#         p_e = random.choices([0.08, 0.1, 0.15, 0.3], [0.4, 0.05, 0.5, 0.05])[0]
#     elif age == 'A':
#         p_e = random.choices([0.08, 0.1, 0.15, 0.3], [0.6, 0.05, 0.3, 0.05])[0]
#     else:
#         p_e = random.choices([0.08, 0.1, 0.2], [0.7, 0.25, 0.05])[0]
#     p_e = 0.3
    return p_e

def age_based_nc1_lam(age):
    if age == 'C':
        nc1_lam = 2
    elif age == 'Y':
        nc1_lam = 1.5
    elif age == 'A':
        nc1_lam = 1
    else:
        nc1_lam = 0.8
    return nc1_lam

def epidemic1D_age(pop1, ages, t_e, t_i, t_u):
    '''
    this stochastic epidemic simulation calculates a new pop2
    vector of 's', 'e', i', 'u', 'r', and 'f' from the current pop1
    
    The number of contacts of the contagious ('e', 'i', 'u') is generated by a poisson distribution. We assume
    that 'e' and 'u' individuals have the same rate of contacts nc1_lam. However, 'i' individuals have a lower
    rate of contacts nc2_lam.
    
    `t_e`, `t_i`, and `t_u` dictionaries explained:
    The moment an individual becomes exposed, we add them to dictionary 't_e' with the number of days left that
    they will remain in that state. After this number becomes 0, we remove them from 't_e' and see whether they
    become 'i' or 'u', that is symptomatic or asymptomatic, respectively. For 'i' and 'u', we generate the number
    of days in their respective states from a uniform distribution ranging from `min_infect` to `max_infect`. At
    the end of the countdown for a symptomatic individual, 'i', they will either recover (with probability p_i)
    or die (probability p_f = 1-p_i). At the end of the countdown for an asymptomatic individual, 'u', they
    will recover.
    '''
    # initial times in state left
    t_e2 = t_e.copy()
    t_i2 = t_i.copy()
    t_u2 = t_u.copy()
    
    pop2=pop1.copy() # population after contacts
    n=np.array(pop1).shape[0]
    
    
    # iterate through each individual
    for j in range(n):
        age_j = ages[j]
        # if person is exposed or undetected (assumption: they do NOT change behavior, so number of contacts is same)
        if pop1[j]=='e' or pop1[j]=='u':
            # number of contacts
            nc1_lam = age_based_nc1_lam(age_j)
            nc1 = np.random.poisson(nc1_lam)
            
            # generate contacts and with probability p_e, an 's' individual will become 'e'
            for c in range(nc1):
                k=j
                while k==j and pop1[k]!='f': # make sure we only count contacts with a different and alive individual
                    k=np.random.randint(n)
                    age_k = ages[k]
                
                # see if susceptible person is exposed
                if pop1[k]=='s' and np.random.rand() < age_based_p_e(age_k):
                    pop2[k]='e'
                    t_e2[k] = incubate_time
        
        # if person is infected (assumption: they change behavior, so number of contacts is fewer)
        if pop1[j]=='i':
            # number of contacts
            nc2 = np.random.poisson(nc2_lam)
            
            # generate contacts and with probability p_e, an 's' individual will become 'e'
            for c in range(nc2):
                k=j
                while k==j and pop1[k]!='f': # make sure we only count contacts with a different and alive individual
                    k=np.random.randint(n)
                    age_k = ages[k]
                
                # see if susceptible person is exposed
                if pop1[k]=='s' and np.random.rand() < age_based_p_e(age_k):
                    pop2[k]='e'
                    t_e2[k] = incubate_time
        
    # update time left in 'e', 'i', and 'u' states
    
    for key in t_e:
        time = t_e2.pop(key) - 1
        age_key_exposed = ages[key]
        if time > 0:
            t_e2[key] = time
        else:
            if np.random.rand() < age_based_p_i(age_key_exposed): # symptomatic
                pop2[key] = 'i'
                t_i2[key] = int(np.random.uniform(min_infect,max_infect))
            else: # undetected/asymptomatic
                pop2[key] = 'u'
                t_u2[key] = int(np.random.uniform(min_infect,max_infect))
            
    for key in t_i:
        time = t_i2.pop(key) - 1
        age_key_infected = ages[key]
        if time > 0:
            t_i2[key] = time
        else:
            if np.random.rand() < age_based_p_f(age_key_infected): # fatality
                pop2[key] = 'f'
            else: # recovered
                pop2[key] = 'r'
                
    for key in t_u:
        time = t_u2.pop(key) - 1
        if time > 0:
            t_u2[key] = time
        else: # recovery
            pop2[key] = 'r'
        
    return pop2, t_e2, t_i2, t_u2

def plot_realizations(n_realizations):
    '''
    Produces a plot with many realizations of S, I, R populations vs time
    Inputs: n_realizations: number of realizations to plot
    '''
    # Create dictionaries to store the times and results of each realization
    tts = {}
    results = {}
    results_by_age = {}

    # Simulate n_realizations given the p, nc, pt values passed to the function
    for i in range(n_realizations):
        tts[i], results[i], results_by_age[i] = simulate1D()
    
    # Create the figure
    plt.figure(figsize=(12,9))

    # Iterate through each realization and plot
    for key in tts:
        # Separate results array to S, I, R arrays
        S, E, I, U, R, F = np.transpose(results[key])
        plt.plot(tts[key], S, color = 'blue', linewidth=1)
        plt.plot(tts[key], E, color = 'orange', linewidth=1)
        plt.plot(tts[key], I, color = 'green', linewidth=1)
        plt.plot(tts[key], U, color = 'red', linewidth=1)
        plt.plot(tts[key], R, color = 'purple', linewidth=1)
        plt.plot(tts[key], F, color = 'brown', linewidth=1)

    # Formatting
    plt.title(f'Evolution of Populations over Time for {n_realizations} realizations')
    plt.xlabel('Time (days)')
    plt.ylabel('Population')
    plt.legend(['S', 'E', 'I', 'U', 'R', 'F' ])

"""## Plot Curves by Age"""

def plot_curves_by_age(age, results_by_age):
    stats_over_time = []
    for timestep in results_by_age:
        stats_over_time.append(timestep[age])
        
    age_to_title_str = {'A': 'Adult', 'Y': 'Young Adult', 'E': 'Elderly', 'C': 'Children'}
        
    labels = ['S', 'E', 'I', 'U', 'R', 'F']

    for y_arr, label in zip(np.transpose(stats_over_time), labels):
        plt.plot(tt, y_arr, label=label)

    plt.title('Evolution of Populations over Time â€“ ' + age_to_title_str[age])
    plt.xlabel('Time (days)')
    plt.ylabel('Population')
    plt.legend();

plot_curves_by_age('A', results_by_age)

plot_curves_by_age('C', results_by_age)

plot_curves_by_age('Y', results_by_age)

plot_curves_by_age('E', results_by_age)

"""## Stacked Plots by Age Group for Each Compartment"""

def compartment_over_time(compartment, results_by_age):
    compartment_to_num = {'s': 0, 'e': 1, 'i': 2, 'u': 3, 'r': 4, 'f': 5}
    num = compartment_to_num[compartment]
    
    data_over_time = []
    for timestep in results_by_age:
        data_over_time.append([item[num] for item in list(timestep.values())])
    
    data_by_age = []
    for i in range(4):
        data_by_age.append([item[i] for item in data_over_time])
        
    timerange = range(len(results_by_age))
    plt.stackplot(timerange, data_by_age[0], data_by_age[1], data_by_age[2], data_by_age[3]);
    compartment_to_title_str = {'s': 'Susceptible', 'e': 'Exposed', 'i': 'Infected', 
                                'u': 'Undetected', 'r': 'Recovered', 'f': 'Deceased'}
    
    age_to_title_str = {'A': 'Adult', 'Y': 'Young Adult', 'E': 'Elderly', 'C': 'Children'}
    legend_list = []
    for age_group in results_by_age[0].keys():
        legend_list.append(age_to_title_str[age_group])
    
    plt.legend(legend_list);
    plt.title('Number of ' + compartment_to_title_str[compartment])
    plt.xlabel('Day')
    plt.ylabel('Number of Individuals in Population')

compartment_over_time('s', results_by_age)

compartment_over_time('e', results_by_age)

compartment_over_time('i', results_by_age)

compartment_over_time('u', results_by_age)

compartment_over_time('r', results_by_age)

compartment_over_time('f', results_by_age)

"""## Average Data Over Realizations"""

def average_over_realizations(n_realizations):
     # Create dictionaries to store the times and results of each realization
    tts = {}
    results = {}
    results_by_age = {}

    # Simulate n_realizations given the p, nc, pt values passed to the function
    for i in range(n_realizations):
        tts[i], results[i], results_by_age[i] = simulate1D()
        
    timesteps_per_realization = []
    for n in range(n_realizations):
        timesteps_per_realization.append(len(list(results.values())[n]))
    
    max_num_timesteps = max(timesteps_per_realization)
        
    for n in range(n_realizations):
        if len(results[n]) < max_num_timesteps:
            new_val = results[n] + [results[n][-1]]*(max_num_timesteps - len(results[n]))
            results[n] = new_val
    
    avg_over_realizations = np.average(np.array(list(results.values())), axis = 0)
    
    return avg_over_realizations

averaged_data = average_over_realizations(5)

averaged_data