# -*- coding: utf-8 -*-
"""Python Code_Individual Agent Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14kfqUdfLHzDLLx1moxhM8_TvzSO09DbC

### For questions regarding the code, contact David Wei @ davidwei@g.harvard.edu ###
"""

import numpy as np
import matplotlib.pyplot as plt

def simulate1D(n,nc,pt):
    """
    this function packages the simulation steps of intializng the population
    vector and iterating the epidemic and census functions unit I=0
    the censuses are accumulated in a matrix, results
    """
    t=0
    pop=initial1D(n,0,0)
    pop[int(n/2)-1]='i'
    s,i,r=census1D(pop)
    results=[[s,i,r]]
    tt=[t]
    while i>0:
        pop=epidemic1D(nc,pt,pop)
        s,i,r=census1D(pop)
        results.append([s,i,r])
        t=t+1
        tt.append(t)
    return tt,results

def initial1D(s0,i0,r0):
    '''
    sets an initial population vector for the epidemic simulation
    each state subpopulation is appended to the growing vector, pop
    NOTE: if position in the array is important,eg. if you are modeling
    local neighborhood contacts, each individual must be placed 
    randomly in the array
    '''
    
    pop=[]
    for i in range(s0):
        pop.append('s')
    for i in range(i0):
        pop.append('i')
    for i in range(r0):
        pop.append('r')
    return pop

def census1D(pop):
    # counts the number of s, i and r cells in pop
    s=0
    i=0
    r=0
    n=np.array(pop).shape[0]
    for j in range(n):
        if pop[j]=='s':
            s+=1
        elif pop[j]=='i':
            i+=1
        elif pop[j]=='r':
            r+=1
    return s,i,r

def epidemic1D(nc,pt,pop1):
    '''
    this stochastic epidemic simulation calculates a new pop2
    vector of 's', 'i', and 'r' from the current pop1 assuming
    that all 'i' cells go to 'r' after each has nc random
    infectious contacts with other cells. An 's' cell goes
    to 'i' with probability, pt, if it is contacted by an 'i'.
    op2=pop1;  %set up new vector
    '''
    pop2=pop1.copy()
    n=np.array(pop1).shape[0]
    for j in range(n):
        if pop1[j]=='i':
            for c in range(nc):
                k=j
                while k==j:
                    k=np.random.randint(n)
                if pop1[k]=='s' and np.random.rand()<pt:
                    pop2[k]='i'
            pop2[j]='r'
    return pop2

"""## **Examples:**"""

# Example
tt,results=simulate1D(9999,4,0.5)
print(results)

plt.figure()

labels = ['S', 'I', 'R']

for y_arr, label in zip(np.transpose(results), labels):
    plt.plot(tt, y_arr, label=label)
    
plt.title('n = 9999, nc = 4, pt = 0.5')
plt.xlabel('Time')
plt.ylabel('Population')
plt.legend()

def plot_realizations(n_realizations, p, nc, pt):
    '''
    Produces a plot with many realizations of S, I, R populations vs time
    Inputs: n_realizations: number of realizations to plot;
            p: population;
            nc: number of random infectious contacts with other cells;
            pt: probability of infection;
    '''
    # Create dictionaries to store the times and results of each realization
    tts = {}
    results = {}

    # Simulate n_realizations given the p, nc, pt values passed to the function
    for i in range(n_realizations):
        tts[i], results[i] = simulate1D(p, nc, pt)
    
    # Create the figure
    plt.figure(figsize=(10,6))
    labels = ['S', 'I', 'R']

    # Iterate through each realization and plot
    for key in tts:
        # Separate results array to S, I, R arrays
        S, I, R = np.transpose(results[key])
        plt.plot(tts[key], S, color = 'b', linewidth=0.5)
        plt.plot(tts[key], I, color = 'r', linewidth=0.5)
        plt.plot(tts[key], R, color = 'g', linewidth=0.5)

    # Formatting
    plt.title(f'n = {p}, nc = {nc:.2f}, pt = {pt:.2f}')
    plt.xlabel('Time')
    plt.ylabel('Population')
    plt.legend(['S', 'I', 'R'])

"""### 1. IAS Model when $nc \times pt = 2 \times \log(2)$"""

# Create 100 realizations
n_realizations = 100

p = 1000 # population
nc_array = np.array([2, 6, 10, 14, 18])
pt_array = 2 * np.log(2)/nc_array


for i in range(len(nc_array)):
    plot_realizations(n_realizations, p, nc_array[i], pt_array[i])

"""### 2. IAS Model when $nc \times pt = 2$"""

# Create 100 realizations
n_realizations = 100

p = 1000 # population
nc_array = np.array([2, 6, 10, 14, 18])
pt_array = nc_array * 0.5


for i in range(len(nc_array)):
    plot_realizations(n_realizations, p, nc_array[i], pt_array[i])

"""### 3. Comparing IAS models when $nc = 4$ and $pt = 0.5$ to $nc = 20$ and $pt = 0.1$ for varying population sizes"""

# Create 100 realizations
n_realizations = 100

p_array = [600, 700, 800, 900, 1000]

for i in range(len(p_array)):
    plot_realizations(n_realizations, p_array[i], 4, 0.5)
    plot_realizations(n_realizations, p_array[i], 20, 0.1)